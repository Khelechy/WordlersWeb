/**
 * Minified by jsDelivr using Terser v5.15.0.
 * Original file: /npm/@microsoft/signalr-protocol-msgpack@6.0.9/dist/esm/MessagePackHubProtocol.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Encoder,Decoder}from"@msgpack/msgpack";import{LogLevel,MessageType,NullLogger,TransferFormat}from"@microsoft/signalr";import{BinaryMessageFormat}from"./BinaryMessageFormat";import{isArrayBuffer}from"./Utils";const SERIALIZED_PING_MESSAGE=new Uint8Array([145,MessageType.Ping]);export class MessagePackHubProtocol{constructor(e){this.name="messagepack",this.version=1,this.transferFormat=TransferFormat.Binary,this._errorResult=1,this._voidResult=2,this._nonVoidResult=3,e=e||{},this._encoder=new Encoder(e.extensionCodec,e.context,e.maxDepth,e.initialBufferSize,e.sortKeys,e.forceFloat32,e.ignoreUndefined,e.forceIntegerToFloat),this._decoder=new Decoder(e.extensionCodec,e.context,e.maxStrLength,e.maxBinLength,e.maxArrayLength,e.maxMapLength,e.maxExtLength)}parseMessages(e,t){if(!isArrayBuffer(e))throw new Error("Invalid input for MessagePack hub protocol. Expected an ArrayBuffer.");null===t&&(t=NullLogger.instance);const r=BinaryMessageFormat.parse(e),s=[];for(const e of r){const r=this._parseMessage(e,t);r&&s.push(r)}return s}writeMessage(e){switch(e.type){case MessageType.Invocation:return this._writeInvocation(e);case MessageType.StreamInvocation:return this._writeStreamInvocation(e);case MessageType.StreamItem:return this._writeStreamItem(e);case MessageType.Completion:return this._writeCompletion(e);case MessageType.Ping:return BinaryMessageFormat.write(SERIALIZED_PING_MESSAGE);case MessageType.CancelInvocation:return this._writeCancelInvocation(e);default:throw new Error("Invalid message type.")}}_parseMessage(e,t){if(0===e.length)throw new Error("Invalid payload.");const r=this._decoder.decode(e);if(0===r.length||!(r instanceof Array))throw new Error("Invalid payload.");const s=r[0];switch(s){case MessageType.Invocation:return this._createInvocationMessage(this._readHeaders(r),r);case MessageType.StreamItem:return this._createStreamItemMessage(this._readHeaders(r),r);case MessageType.Completion:return this._createCompletionMessage(this._readHeaders(r),r);case MessageType.Ping:return this._createPingMessage(r);case MessageType.Close:return this._createCloseMessage(r);default:return t.log(LogLevel.Information,"Unknown message type '"+s+"' ignored."),null}}_createCloseMessage(e){if(e.length<2)throw new Error("Invalid payload for Close message.");return{allowReconnect:e.length>=3?e[2]:void 0,error:e[1],type:MessageType.Close}}_createPingMessage(e){if(e.length<1)throw new Error("Invalid payload for Ping message.");return{type:MessageType.Ping}}_createInvocationMessage(e,t){if(t.length<5)throw new Error("Invalid payload for Invocation message.");const r=t[2];return r?{arguments:t[4],headers:e,invocationId:r,streamIds:[],target:t[3],type:MessageType.Invocation}:{arguments:t[4],headers:e,streamIds:[],target:t[3],type:MessageType.Invocation}}_createStreamItemMessage(e,t){if(t.length<4)throw new Error("Invalid payload for StreamItem message.");return{headers:e,invocationId:t[2],item:t[3],type:MessageType.StreamItem}}_createCompletionMessage(e,t){if(t.length<4)throw new Error("Invalid payload for Completion message.");const r=t[3];if(r!==this._voidResult&&t.length<5)throw new Error("Invalid payload for Completion message.");let s,a;switch(r){case this._errorResult:s=t[4];break;case this._nonVoidResult:a=t[4]}return{error:s,headers:e,invocationId:t[2],result:a,type:MessageType.Completion}}_writeInvocation(e){let t;return t=e.streamIds?this._encoder.encode([MessageType.Invocation,e.headers||{},e.invocationId||null,e.target,e.arguments,e.streamIds]):this._encoder.encode([MessageType.Invocation,e.headers||{},e.invocationId||null,e.target,e.arguments]),BinaryMessageFormat.write(t.slice())}_writeStreamInvocation(e){let t;return t=e.streamIds?this._encoder.encode([MessageType.StreamInvocation,e.headers||{},e.invocationId,e.target,e.arguments,e.streamIds]):this._encoder.encode([MessageType.StreamInvocation,e.headers||{},e.invocationId,e.target,e.arguments]),BinaryMessageFormat.write(t.slice())}_writeStreamItem(e){const t=this._encoder.encode([MessageType.StreamItem,e.headers||{},e.invocationId,e.item]);return BinaryMessageFormat.write(t.slice())}_writeCompletion(e){const t=e.error?this._errorResult:e.result?this._nonVoidResult:this._voidResult;let r;switch(t){case this._errorResult:r=this._encoder.encode([MessageType.Completion,e.headers||{},e.invocationId,t,e.error]);break;case this._voidResult:r=this._encoder.encode([MessageType.Completion,e.headers||{},e.invocationId,t]);break;case this._nonVoidResult:r=this._encoder.encode([MessageType.Completion,e.headers||{},e.invocationId,t,e.result])}return BinaryMessageFormat.write(r.slice())}_writeCancelInvocation(e){const t=this._encoder.encode([MessageType.CancelInvocation,e.headers||{},e.invocationId]);return BinaryMessageFormat.write(t.slice())}_readHeaders(e){const t=e[1];if("object"!=typeof t)throw new Error("Invalid headers.");return t}}
//# sourceMappingURL=/sm/260893d0d3e4bb6e79bdddaf6f72e1b08a36c700b5117aef790d4142b25c280e.map